/* 
   javascript for tasks/gis/new
 */

var TW = TW || {};
TW.tasks = TW.tasks || {};
TW.tasks.gis = TW.tasks.gis || {};
TW.tasks.gis.asserted_distributions = TW.tasks.asserted_distributions || {};

Object.assign(TW.tasks.gis.asserted_distributions, {

  init_asserted_distributions_map: function () {
    if ($("#new_asserted_distribution_map_canvas").length) {
      if (document.getElementById('feature_collection') != null) {
        var newadwidget = $("#feature_collection");
        var fcdata = newadwidget.data('feature-collection');
        //    alert(fcdata);
        var map = TW.vendor.lib.google.maps.initializeMap("new_asserted_distribution_map_canvas", fcdata); // fcdata
        TW.tasks.gis.asserted_distributions.add_new_asserted_distribution_map_listeners(map);
      }
    }
  },

  // TODO Rich- move this to general JS libraries
  clear_map: function (map) {
    // quick_new_asserted_distribution_form and feature collection geoJSON
    map.data.forEach(function (feature) {
      map.data.remove(feature);
    });    // clear the map.data

  },

  // TODO: Rich move this to the general maps library
  set_bounds: function(feature_collection) {
      // original map canvas parameters are now lost, so we have to find them again
      var bounds = {};
      var children = feature_collection.parentElement.children;
      
      for (var m = 0; m < children.length; m++) {
        if (children[m].id.search("_canvas") >= 0) {
          bounds.canvas_width = children[m].style.width.toString().split('px')[0];
          bounds.canvas_height = children[m].style.height.toString().split('px')[0];
          bounds.canvas_ratio = bounds.canvas_width / bounds.canvas_height;
          break;
        }
      }
      return bounds
  },

  new_asserted_distribution_check_preemption: function () {       // page-specific check for postback prerequisites
          // add_listeners end
    if ($("[name=asserted_distribution\\[origin_citation_attributes\\]\\[source_id\\]]")[0].value == ""  ) { // ")[0].value == "") {   // slightly convoluted since name not id
    // if ($("[name=asserted_distribution\\[origin_citation_attributes\\]\\[source_id\\]]")[0].value == "") {   // slightly convoluted since name not id
      $("#sourceError").text("Please set a source before selecting an area!");
      return true;
    }
    else {
      $("#sourceError").text("");
      return false;
    }
  },

  bind_create_buttons: function () {
    $("[id^=button_]").click(function () {        // set mouseout for each area (condensed)
      var form = $("#new_asserted_distribution_from_map_form");  
      form.append($('<input hidden name="asserted_distribution[geographic_area_id]" value="' + $(this).data('geographic-area-id') + '">' ));
    });
  },
  
  bind_mouseover: function(map) {
    $("[id^=button_]").mouseover(function () {       // set mouseover for each area
      var this_id = this.id;
      var area_id = $(this).data('geographic-area-id');
      map.data.forEach(function (feature) {        // find by geographic area id
        var this_feature = feature;
        var this_property = this_feature.getProperty('geographic_area');
        if (this_property.id != area_id) {
          map.data.overrideStyle(this_feature, {strokeWeight: 0.0});      // erase borders
          map.data.overrideStyle(this_feature, {fillOpacity: 0.0});       // transparent
        }
        if (this_property.id == area_id) {
          map.data.overrideStyle(this_feature, {fillColor: '#FF0000'});  // red
          map.data.overrideStyle(this_feature, {strokeWeight: 2});       // embolden borders
          map.data.overrideStyle(this_feature, {fillOpacity: 1.0});      // transparent
        }
      });
    });
  },

  bind_mouseout: function(map) {
    $("[id^=button_]").mouseout(function () {        // set mouseout for each area (condensed)
      var this_id = this.id;                      // var this since it goes out of scope with .forEach
      map.data.forEach(function (feature) {        // find by geographic area id
        if (feature.getProperty('geographic_area').id == $(this).data('geographic-area-id') ) {
          map.data.revertStyle();
        }
      });
    });
  },

  add_click_services_to_new_asserted_distribution_map: function (map, event) {     // click event passed in
    // captures and displays map coordinates from click event thru asserted_distribution/new.html.erb..span:map_coords
    // checks for preemptive condition
    // requests and displays choices from asserted_distribution_controller thru .../new...span:qnadf
    // clears previous map data features
    // sets mouseover/mouseout behavior for buttons via forEach(function(feature))
    //   in map.data corresponding to "button_nnnn" where nnnn is area id
    // resizes, recenters map based on new features

    if (this.new_asserted_distribution_check_preemption()) {
      return;
    };

    var mapLatLng = event.latLng;
    $("#map_coords").html('Coordinates: Latitude = ' + mapLatLng.lat().toFixed(6) + ' , Longitude = ' + mapLatLng.lng().toFixed(6));
    $("#latitude").val(mapLatLng.lat());
    $("#longitude").val(mapLatLng.lng());

    $.get('generate_choices', $('form#new_asserted_distribution_from_map_form').serialize(), function (local_data) {
      $("#choices").html(local_data['html']);              // render the html  

      TW.tasks.gis.asserted_distributions.bind_create_buttons();

      var data = local_data['feature_collection'];
      TW.tasks.gis.asserted_distributions.clear_map(map);

      map.data.addGeoJson(data);      // add the geo features corresponding to the forms

      TW.tasks.gis.asserted_distributions.bind_mouseover(map);
      TW.tasks.gis.asserted_distributions.bind_mouseout(map);

      // TODO: all of the following code should be in general maps library
      //       called something like TW.vendor.lib.google.maps.bound_and_recenter(map, feature_collection)
      // TODO: where the hell is feature_collection getting initialized?! 
      var bounds = TW.tasks.gis.asserted_distributions.set_bounds(feature_collection)
      
      TW.vendor.lib.google.maps.getData(data, bounds);
      var center_lat_long = TW.vendor.lib.google.maps.get_window_center(bounds);
      map.setCenter(center_lat_long);
      map.setZoom(bounds.gzoom);
    },
      'json' // expect a JSON response
    );
  },

  add_new_asserted_distribution_map_listeners: function (map) {      // 4 listeners, one for map as a whole 3 for map.data features
    // When the user clicks, set 'isColorful', changing the color of the feature.
    map.data.addListener('click', function (event) {
      if (event.feature.getProperty('isColorful')) {           // reset selected color if
        event.feature.setProperty('isColorful', false);     // previously selected
        event.feature.setProperty('fillColor', "#440000");  // to dimmer red
      }
      else {      // if not already "Colorful", make it so
        event.feature.setProperty('isColorful', true);
        event.feature.setProperty('fillColor', "#CC0000");  //brighter red
      }
      ;
      TW.tasks.gis.asserted_distributions.add_click_services_to_new_asserted_distribution_map(map, event);
    });

    // When the user hovers, tempt them to click by outlining the letters.
    // Call revertStyle() to remove all overrides. This will use the style rules
    // defined in the function passed to setStyle()
    map.data.addListener('mouseover', function (event) {
      map.data.revertStyle();
      map.data.overrideStyle(event.feature, {fillColor: '#880000'});  // mid-level red
      map.data.overrideStyle(event.feature, {strokeWeight: 2});       //embolden borders
      map.data.overrideStyle(event.feature, {icon: '<%= asset_path("map_icons/mm_20_brown.png") %>'});       // highlight markers
    });

    map.data.addListener('mouseout', function (event) {
      map.data.revertStyle();
    });

    google.maps.event.addListener(map, 'click', function (event) {
      TW.tasks.gis.asserted_distributions.add_click_services_to_new_asserted_distribution_map(map, event);
    });
  }, 

  //created to isolate functions above and debug mouseover
  add_mouseOver_Out_listeners: function (map) {   
    // When the user clicks, set 'isColorful', changing the color of the feature.
    map.data.addListener('click', function (event) {
      if (event.feature.getProperty('isColorful')) {        // reset selected color if
        event.feature.setProperty('isColorful', false);     // previously selected
        event.feature.setProperty('fillColor', "#440000");  // to dimmer red
      }
      else {      // if not already "Colorful", make it so
        event.feature.setProperty('isColorful', true);
        event.feature.setProperty('fillColor', "#CC0000");  //brighter red
      }
      ;
    });
    
    map.data.addListener('mouseover', function (event) {
      map.data.revertStyle();
      map.data.overrideStyle(event.feature, {fillColor: '#880000'});  // mid-level red
      map.data.overrideStyle(event.feature, {strokeWeight: 2});       //embolden borders
      map.data.overrideStyle(event.feature, {icon: '<%= asset_path("map_icons/mm_20_brown.png") %>'});       // highlight markers
    });

    map.data.addListener('mouseout', function (event) {
      map.data.revertStyle();
    });
  } 
}
); // end widget

$(document).ready(TW.tasks.gis.asserted_distributions.init_asserted_distributions_map);

